{"version":3,"file":"three.interaction.module.js","sources":["../src/utils/Utils.js","../src/patch/EventDispatcher.js","../src/patch/Object3D.js","../src/interaction/InteractionData.js","../src/interaction/InteractionEvent.js","../src/interaction/InteractionTrackingData.js","../src/interaction/InteractionManager.js","../src/interaction/InteractionLayer.js","../src/utils/Raf.js","../src/utils/Ticker.js","../src/interaction/Interaction.js"],"sourcesContent":["/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\nexport const Utils = {\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: (function() {\n    const ks = _rt(function() {});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined(variable) {\n    return typeof variable === 'undefined';\n  },\n};\n","import { EventDispatcher, Object3D } from 'three';\nimport { Utils } from '../utils/Utils.js';\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  if (this instanceof Object3D) this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nEventDispatcher.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = (ev) => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @return {this} this\n */\nEventDispatcher.prototype.emit = function(type, ...argument) {\n  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n  const cbs = this._listeners[type] || [];\n  const cache = cbs.slice(0);\n\n  for (let i = 0; i < cache.length; i++) {\n    cache[i].apply(this, argument);\n  }\n  return this;\n};\n\n","import { Object3D } from 'three';\n\n/**\n * whether displayObject is interactively\n */\nObject3D.prototype.interactive = false;\n\n/**\n * whether displayObject's children is interactively\n */\nObject3D.prototype.interactiveChildren = true;\n\n/**\n * whether displayObject had touchstart\n * @private\n */\nObject3D.prototype.started = false;\n\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  },\n});\n\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\nObject3D.prototype.raycastTest = function(raycaster) {\n  const result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n","import { Vector2 } from 'three';\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\nclass InteractionData {\n  /**\n   * InteractionData constructor\n   */\n  constructor() {\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n    this.global = new Vector2();\n\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n    this.originalEvent = null;\n\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n    this.identifier = null;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n    this.isPrimary = false;\n\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n    this.button = 0;\n\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n    this.buttons = 0;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n    this.tiltX = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n    this.tiltY = 0;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n    this.pointerType = null;\n\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n    this.pressure = 0;\n\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n    this.rotationAngle = 0;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.twist = 0;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.tangentialPressure = 0;\n  }\n\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n  get pointerId() {\n    return this.identifier;\n  }\n\n  /**\n   * Copies properties from normalized event data.\n   *\n   * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n   * @private\n   */\n  _copyEvent(event) {\n    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n    // it with \"false\" on later events when our shim for it on touch events might not be\n    // accurate\n    if (event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.width = event.width;\n    this.height = event.height;\n    this.tiltX = event.tiltX;\n    this.tiltY = event.tiltY;\n    this.pointerType = event.pointerType;\n    this.pressure = event.pressure;\n    this.rotationAngle = event.rotationAngle;\n    this.twist = event.twist || 0;\n    this.tangentialPressure = event.tangentialPressure || 0;\n  }\n\n  /**\n   * Resets the data for pooling.\n   *\n   * @private\n   */\n  _reset() {\n    // isPrimary is the only property that we really need to reset - everything else is\n    // guaranteed to be overwritten\n    this.isPrimary = false;\n  }\n}\n\nexport default InteractionData;\n","/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\nclass InteractionEvent {\n  /**\n   * InteractionEvent constructor\n   */\n  constructor() {\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n    this.stopped = false;\n\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n    this.currentTarget = null;\n\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n    this.type = null;\n\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n    this.data = null;\n\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersects}\n     */\n    this.intersects = [];\n  }\n\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n  stopPropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Resets the event.\n   *\n   * @private\n   */\n  _reset() {\n    this.stopped = false;\n    this.currentTarget = null;\n    this.target = null;\n    this.intersects = [];\n  }\n}\n\nexport default InteractionEvent;\n","/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\nexport default class InteractionTrackingData {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  constructor(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n  _doSet(flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & (~flag);\n    }\n  }\n\n  /**\n   * Unique pointer id of the event\n   *\n   * @readonly\n   * @member {number}\n   */\n  get pointerId() {\n    return this._pointerId;\n  }\n\n  /**\n   * State of the tracking data, expressed as bit flags\n   *\n   * @member {number}\n   */\n  get flags() {\n    return this._flags;\n  }\n\n  /**\n   * Set the flags for the tracking data\n   *\n   * @param {number} flags - Flags to set\n   */\n  set flags(flags) {\n    this._flags = flags;\n  }\n\n  /**\n   * Is the tracked event inactive (not over or down)?\n   *\n   * @member {number}\n   */\n  get none() {\n    return this._flags === this.constructor.FLAGS.NONE;\n  }\n\n  /**\n   * Is the tracked event over the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get over() {\n    return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n  }\n\n  /**\n   * Set the over flag\n   *\n   * @param {boolean} yn - Is the event over?\n   */\n  set over(yn) {\n    this._doSet(this.constructor.FLAGS.OVER, yn);\n  }\n\n  /**\n   * Did the right mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get rightDown() {\n    return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the right down flag\n   *\n   * @param {boolean} yn - Is the right mouse button down?\n   */\n  set rightDown(yn) {\n    this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n  }\n\n  /**\n   * Did the left mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get leftDown() {\n    return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the left down flag\n   *\n   * @param {boolean} yn - Is the left mouse button down?\n   */\n  set leftDown(yn) {\n    this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n  }\n}\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2,\n});\n","import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionManager extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    super();\n\n    options = options || {};\n\n    this.objects = null;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    this.raycaster.setFromCamera(interactionData.global, this.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    if (this.objectsToRaycast) {\n      interactionEvent.intersects = this.raycaster.intersectObjects(this.objectsToRaycast, true);\n    } else {\n      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n    }\n    return interactionEvent;\n  }\n\n  /**\n   * set objects to raycast\n   *\n   * @param {Object3D} objects\n   * @memberof InteractionManager\n   */\n  setObjectsToRaycast(objects) {\n    this.objectsToRaycast = objects;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionManager;\n","import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionLayer extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Layer}\n     */\n    this.layer = null;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    // this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    // this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionLayer#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionLayer#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionLayer#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionLayer#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionLayer#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionLayer#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionLayer#event:mousedown}.\n     *\n     * @event InteractionLayer#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionLayer#event:rightdown}.\n     *\n     * @event InteractionLayer#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionLayer#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionLayer#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionLayer#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionLayer#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionLayer#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionLayer#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionLayer#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.\n     *\n     * @event InteractionLayer#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionLayer#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionLayer#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionLayer#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionLayer#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionLayer#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionLayer#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionLayer#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionLayer#event:touchstart}.\n     *\n     * @event InteractionLayer#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionLayer#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isAble() {\n    return this.layer && this.layer.interactive;\n  }\n\n  /**\n   * set layer\n   * @param {Layer} layer layer\n   */\n  setLayer(layer) {\n    this.layer = layer;\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    if (!this.isAble()) return null;\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.layer.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    if (!this.isAble()) return;\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.layer.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (!this.isAble()) return;\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.layer.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    if (!this.isAble()) return;\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionLayer;\n","(function() {\n  let lastTime = 0;\n  let vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n            window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback) {\n      let currTime = new Date().getTime();\n      let timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      let id = window.setTimeout(function() {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n","import './Raf';\nimport { EventDispatcher } from 'three';\n\n/**\n * @extends EventDispatcher\n */\nclass Ticker extends EventDispatcher {\n  /**\n   *\n   */\n  constructor() {\n    super();\n    this.timer = null;\n    this.started = false;\n\n    /**\n     * pre-time cache\n     *\n     * @member {Number}\n     * @private\n     */\n    this.pt = 0;\n\n    /**\n     * how long the time through, at this tick\n     *\n     * @member {Number}\n     * @private\n     */\n    this.snippet = 0;\n\n    this.start();\n  }\n\n  /**\n   * start tick loop\n   */\n  start() {\n    if (this.started) return;\n    const loop = () => {\n      this.timeline();\n      this.emit('tick', { snippet: this.snippet });\n      this.timer = RAF(loop);\n    };\n    loop();\n  }\n\n  /**\n   * stop tick loop\n   */\n  stop() {\n    CAF(this.timer);\n    this.started = false;\n  }\n\n  /**\n   * get timeline snippet\n   *\n   * @private\n   */\n  timeline() {\n    this.snippet = Date.now() - this.pt;\n    if (this.pt === 0 || this.snippet > 200) {\n      this.pt = Date.now();\n      this.snippet = Date.now() - this.pt;\n    }\n\n    this.pt += this.snippet;\n  }\n}\n\nexport default Ticker;\n","import Ticker from '../utils/Ticker';\nimport InteractionManager from './InteractionManager';\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * import { Interaction } from 'three.interaction';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interaction = new Interaction(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on ...\n *\n * // you can also listen on parent-node or any display-tree node,\n * // source event will bubble up along with display-tree.\n * // you can stop the bubble-up by invoke ev.stopPropagation function.\n * scene.on('touchstart', ev => {\n *   console.log(ev);\n * })\n *\n * @class\n * @extends InteractionManager\n */\nclass Interaction extends InteractionManager {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    options = Object.assign({ autoAttach: false }, options);\n    super(renderer, scene, camera, options);\n\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n    this.ticker = new Ticker();\n\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n    this.update = this.update.bind(this);\n\n    this.on('addevents', () => {\n      this.ticker.on('tick', this.update);\n    });\n\n    this.on('removeevents', () => {\n      this.ticker.off('tick', this.update);\n    });\n\n    this.setTargetElement(this.renderer.domElement);\n  }\n}\n\nexport default Interaction;\n"],"names":["_rt","val","Object","prototype","toString","call","Utils","ks","variable","EventDispatcher","on","type","fn","isFunction","Object3D","interactive","addEventListener","off","removeEventListener","once","cb","ev","emit","_listeners","undefined","isUndefined","cbs","cache","slice","argument","i","length","apply","interactiveChildren","started","defineProperty","_trackedPointers","raycastTest","raycaster","result","raycast","InteractionData","global","Vector2","target","originalEvent","identifier","isPrimary","button","buttons","width","height","tiltX","tiltY","pointerType","pressure","rotationAngle","twist","tangentialPressure","event","InteractionEvent","stopped","currentTarget","data","intersects","InteractionTrackingData","pointerId","_pointerId","_flags","FLAGS","NONE","flag","yn","flags","constructor","OVER","_doSet","RIGHT_DOWN","LEFT_DOWN","freeze","MOUSE_POINTER_ID","hitTestEvent","InteractionManager","renderer","scene","camera","options","objects","autoPreventDefault","interactionFrequency","mouse","set","activeInteractionData","interactionDataPool","eventData","interactionDOMElement","moveWhenInside","eventsAdded","mouseOverRenderer","supportsTouchEvents","window","supportsPointerEvents","PointerEvent","onClick","bind","processClick","onPointerUp","processPointerUp","onPointerCancel","processPointerCancel","onPointerDown","processPointerDown","onPointerMove","processPointerMove","onPointerOut","processPointerOverOut","onPointerOver","cursorStyles","currentCursorMode","cursor","Raycaster","_deltaTime","setTargetElement","domElement","globalPoint","root","processInteractive","element","removeEvents","addEvents","navigator","msPointerEnabled","style","document","snippet","didMove","k","hasOwnProperty","interactionData","interactionEvent","configureInteractionEventForDOMEvent","setCursorMode","mode","assign","displayObject","eventString","func","hitTest","visible","hit","interactiveParent","children","child","childHit","parent","object","events","normalizeToPointerData","isNormalized","preventDefault","getInteractionDataForPointerId","triggerEvent","eventLen","isRightButton","id","trackedPointers","rightDown","leftDown","cancelled","eventAppend","releaseInteractionDataForPointerId","onPointerComplete","trackingData","isTouch","isMouse","test","isDown","over","none","pop","_copyEvent","_reset","push","point","x","y","rect","parentElement","getBoundingClientRect","left","top","pointerEvent","mapPositionToPoint","clientX","clientY","setFromCamera","globalX","globalY","objectsToRaycast","intersectObjects","normalizedEvents","TouchEvent","li","changedTouches","touch","touches","radiusX","radiusY","force","layerX","offsetX","layerY","offsetY","MouseEvent","removeAllListeners","_tempPoint","InteractionLayer","layer","isAble","lastTime","vendors","requestAnimationFrame","cancelAnimationFrame","callback","currTime","Date","getTime","timeToCall","Math","max","setTimeout","RAF","CAF","Ticker","timer","pt","start","loop","timeline","now","Interaction","autoAttach","ticker","update"],"mappings":"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"}